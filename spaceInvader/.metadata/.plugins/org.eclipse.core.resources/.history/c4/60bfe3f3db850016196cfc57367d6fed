/*
 * tank.c
 *
 *  Created on: Sep 21, 2016
 *      Author: superman
 */


#include <stdint.h>
#include "platform.h"
#include "xparameters.h"
#include "xaxivdma.h"
#include "xio.h"
#include "time.h"
#include "unistd.h"

#include "tank.h"	// Do we normally have to include our own h function?
#define TANK_HEIGHT 8
#define GREEN 0x0000FF00
#define BLACK 0x00000000

// Packs each horizontal line of the figures into a single 32 bit word.
#define packword15(b14,b13,b12,b11,b10,b9,b8,b7,b6,b5,b4,b3,b2,b1,b0)  \
((b14 << 14) | (b13 << 13) | (b12 << 12) | (b11 << 11) | (b10 << 10) | \
 (b9  << 9 ) | (b8  << 8 ) | (b7  << 7 ) | (b6  << 6 ) | (b5  << 5 ) | \
 (b4  << 4 ) | (b3  << 3 ) | (b2  << 2 ) | (b1  << 1 ) | (b0  << 0 ) )

 // This seems like a *very bad* way to store the tank data, but this is what
 // we are doing for the moment.
static const int tank_15x8[TANK_HEIGHT] =
{
	packword15(0,0,0,0,0,0,0,1,0,0,0,0,0,0,0),
	packword15(0,0,0,0,0,0,1,1,1,0,0,0,0,0,0),
	packword15(0,0,0,0,0,0,1,1,1,0,0,0,0,0,0),
	packword15(0,1,1,1,1,1,1,1,1,1,1,1,1,1,0),
	packword15(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),
	packword15(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),
	packword15(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),
	packword15(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)
};

#define WORD_WIDTH 15
struct tank{
	int row;
	int col;
}tank;

int left_tank_move_draw[8];
int left_tank_move_take[8];
int right_tank_move_draw[8];
int right_tank_move_take[8];

void init_tank(){
	tank.row = 210;
	tank.col = 160;
}

// This draws (or erases, via the erase bool) an entire tank.
void draw_tank(unsigned int * framePointer, bool erase){
	// Color is either green or black depending on whether erase happens.
	int color = erase ? BLACK : GREEN ;

	int row, col;
	for(row=0;row<TANK_HEIGHT;row++){
		for(col=0;col<WORD_WIDTH;col++){
			if ((tank_15x8[row] & (1<<(WORD_WIDTH-col-1)))) {
				framePointer[(row+tank.row)*640*2 + (col + tank.col)*2] = color;
				framePointer[(row+tank.row)*640*2 + (col + tank.col)*2 + 1] = color;

				framePointer[(row+tank.row)*640*2 + 640 + (col + tank.col)*2] = color;
				framePointer[(row+tank.row)*640*2 + 640 + (col + tank.col)*2+1] = color;
			}
		}
	}
}

// So these all return an array of size 8- cause the tank is 8 pixels tall
// These arrays tell you which pixels you need to black and which you need to draw
int * get_left_tank_take(){
	return left_tank_move_take;
}

int * get_left_tank_draw(){
	return left_tank_move_draw;
}

int * get_right_tank_take(){
	return right_tank_move_take;
}

int * get_right_tank_draw(){
	return right_tank_move_draw;
}



// moves our tank left by a certain number of pixels
void move_left(unsigned int * framePointer){
	/*draw_tank(framePointer, true);
	tank.col -= 1;
	draw_tank(framePointer, false);

	return;*/
	tank.col -= 1;
	int row;
	for(row = 0; row < TANK_HEIGHT; row++){
		switch (row){
		case 0:
			left_tank_move_draw[0] = (row+tank.row)*1280 + (7 + tank.col)*2;
			left_tank_move_take[0] = (row+tank.row)*1280 + (8 + tank.col)*2;
			framePointer[(row+tank.row)*1280 + (7 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (8 + tank.col)*2] = BLACK;
			break;
		case 1:
			framePointer[(row+tank.row)*1280 + (6 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (9 + tank.col)*2] = BLACK;
			left_tank_move_draw[1] = (row+tank.row)*320 + 6 + tank.col;
			left_tank_move_take[1] = (row+tank.row)*320 + 9 + tank.col;
			break;
		case 2:
			framePointer[(row+tank.row)*1280 + (6 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (9 + tank.col)*2] = BLACK;
			left_tank_move_draw[2] = (row+tank.row)*320 + 6 + tank.col;
			left_tank_move_take[2] = (row+tank.row)*320 + 9 + tank.col;
			break;
		case 3:
			framePointer[(row+tank.row)*1280 + (1 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (14 + tank.col)*2] = BLACK;
			left_tank_move_draw[3] = (row+tank.row)*320 + 1 + tank.col;
			left_tank_move_take[3] = (row+tank.row)*320 + 14 + tank.col;
			break;
		case 4:
			framePointer[(row+tank.row)*1280 + (0 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (15 + tank.col)*2] = BLACK;
			left_tank_move_draw[4] = (row+tank.row)*320 + 0 + tank.col;
			left_tank_move_take[4] = (row+tank.row)*320 + 15 + tank.col;
			break;
		case 5:
			framePointer[(row+tank.row)*1280 + (0 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (15 + tank.col)*2] = BLACK;
			left_tank_move_draw[5] = (row+tank.row)*320 + 0 + tank.col;
			left_tank_move_take[5] = (row+tank.row)*320 + 15 + tank.col;
			break;
		case 6:
			framePointer[(row+tank.row)*1280 + (0 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (15 + tank.col)*2] = BLACK;
			left_tank_move_draw[6] = (row+tank.row)*320 + 0 + tank.col;
			left_tank_move_take[6] = (row+tank.row)*320 + 15 + tank.col;
			break;
		case 7:
			framePointer[(row+tank.row)*1280 + (0 + tank.col)*2] = GREEN;
			framePointer[(row+tank.row)*1280 + (15 + tank.col)*2] = BLACK;
			left_tank_move_draw[7] = (row+tank.row)*320 + 0 + tank.col;
			left_tank_move_take[7] = (row+tank.row)*320 + 15 + tank.col;
			break;
		}
	}
}

//moves our tank right by a certain number of pixels
void move_right(unsigned int * framePointer){
	draw_tank(framePointer, true);
	tank.col += 1;
	draw_tank(framePointer, false);

	return;



		tank.col += 1;
		int row;
		for(row = 0; row < TANK_HEIGHT; row++){
			switch (row){
			case 0:
				right_tank_move_draw[0] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[0] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 1:
				right_tank_move_draw[1] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[1] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 2:
				right_tank_move_draw[2] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[2] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 3:
				right_tank_move_draw[3] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[3] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 4:
				right_tank_move_draw[4] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[4] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 5:
				right_tank_move_draw[5] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[5] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 6:
				right_tank_move_draw[6] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[6] = (row+tank.row)*320 + 6 + tank.col;
				break;
			case 7:
				right_tank_move_draw[7] = (row+tank.row)*320 + 7 + tank.col;
				right_tank_move_take[7] = (row+tank.row)*320 + 6 + tank.col;
				break;
			}
		}
}

void fire_tank(unsigned int * framePointer){
	framePointer[(tank.row-1)*1280 + (7 + tank.col)*2] = 0xFFFFFFFF;
	framePointer[(tank.row-2)*1280 + (7 + tank.col)*2] = 0xFFFFFFFF;
	framePointer[(tank.row-3)*1280 + (7 + tank.col)*2] = 0xFFFFFFFF;
}





/*
 * Here are my thoughts.
 * If any move function (or explode funtion)
 * is called on the tank, it knows it has changed.
 * Then when the renderer goes to render the tank,
 * it understands that instead of not drawing anything
 * (or drawing the entire tank, as it does at the beginning)
 * it knows to draw "updated tank," which consists of a black rectangle
 * to delete old tank data, and color rectangles to make new tank data.
 */

